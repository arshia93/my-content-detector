'use client';

import { useState, FormEvent, ChangeEvent, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Textarea } from '@/components/ui/textarea';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { Loader2, ArrowRightIcon, AlertCircle } from 'lucide-react';
import { useApiCallLimit } from '@/hooks/use-api-call-limit';
import { LoginPromptModal } from '@/components/auth/login-prompt-modal';
import { useSupabase } from '@/lib/supabase/provider';
import { useRouter } from 'next/navigation';

interface SaplingSentenceScore {
  sentence: string;
  score: number;
}

interface SaplingDetectionResult {
  score: number;
  sentence_scores?: SaplingSentenceScore[];
  // Add other potential fields from the API response if necessary
}

interface SaplingError {
  error: string;
}

const CHARACTER_LIMIT = 5000;

const LOADING_MESSAGES = [
  "Analyzing text...",
  "Checking for patterns...",
  "Finalizing results..."
];

const SAMPLE_AI_PARAGRAPH = "The advent of sophisticated neural networks has ushered in a new era of content generation. These models, trained on vast datasets of text and code, can produce remarkably human-like prose, compose poetry, and even generate functional software. While the potential applications are immense, ranging from automated journalism to creative writing assistance, concerns about authenticity and misuse persist. The challenge lies in harnessing this powerful technology responsibly, ensuring it augments human creativity rather than replacing it, and developing robust methods to distinguish between human-authored and machine-generated content.";

export function ContentDetectorForm() {
  const [text, setText] = useState<string>('');
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [result, setResult] = useState<SaplingDetectionResult | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [loadingMessageIndex, setLoadingMessageIndex] = useState<number>(0);

  const { session } = useSupabase();
  const router = useRouter();
  const {
    currentChecks,
    isLimitReached,
    incrementChecks,
    showLoginPrompt,
    setShowLoginPrompt,
  } = useApiCallLimit();

  useEffect(() => {
    let intervalId: NodeJS.Timeout;
    if (isLoading) {
      setLoadingMessageIndex(0);
      intervalId = setInterval(() => {
        setLoadingMessageIndex((prevIndex) => (prevIndex + 1) % LOADING_MESSAGES.length);
      }, 2333);
    }
    return () => {
      clearInterval(intervalId);
    };
  }, [isLoading]);

  async function handleSubmit(event: FormEvent<HTMLFormElement>) {
    event.preventDefault();
    
    if (!session?.user && isLimitReached) {
      setShowLoginPrompt(true);
      return;
    }

    setIsLoading(true);
    setResult(null);
    setError(null);

    if (!text.trim()) {
      setError('Please enter some text to analyze.');
      setIsLoading(false);
      return;
    }

    if (text.length > CHARACTER_LIMIT) {
      setError(`Text exceeds maximum length of ${CHARACTER_LIMIT} characters.`);
      setIsLoading(false);
      return;
    }

    if (!session?.user) {
      incrementChecks();
    }

    const timerPromise = new Promise(resolve => setTimeout(resolve, 7000));
    const apiCallPromise = fetch('/api/detect-content', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ text }),
    });

    try {
      const [apiResponse] = await Promise.all([apiCallPromise, timerPromise]);
      const data = await (apiResponse as Response).json();

      if (!(apiResponse as Response).ok) {
        const errorData = data as SaplingError;
        throw new Error(errorData.error || 'Failed to fetch detection results');
      }
      
      setResult(data as SaplingDetectionResult);
    } catch (err) {
      if (err instanceof Error) {
        setError(err.message);
      } else {
        setError('An unknown error occurred.');
      }
    } finally {
      setIsLoading(false);
    }
  }

  function getScoreColor(score: number): string {
    if (score > 0.75) return 'text-red-600';
    if (score > 0.5) return 'text-yellow-600';
    return 'text-green-600';
  }
  
  function getOverallInterpretation(score: number): string {
    if (score > 0.75) return 'Likely AI-Generated';
    if (score > 0.5) return 'Potentially AI-Generated';
    return 'Likely Human-Written';
  }

  return (
    <>
      <Card className="w-full max-w-3xl mx-auto">
        <CardHeader>
          <CardTitle>Was this written by AI or a human?</CardTitle>
          <CardDescription>
            Enter text below to check if it was likely generated by AI. Character limit: {CHARACTER_LIMIT}.
            {!session?.user && (
              <span className="block mt-1 text-sm">
                You have {Math.max(0, 3 - currentChecks)} free checks remaining.
              </span>
            )}
          </CardDescription>
        </CardHeader>
        <CardContent>
          <form onSubmit={handleSubmit} className="space-y-6">
            <Textarea
              placeholder="Paste your text here..."
              value={text}
              onChange={(e: ChangeEvent<HTMLTextAreaElement>) => setText(e.target.value)}
              rows={10}
              maxLength={CHARACTER_LIMIT + 100} 
              className="resize-y"
              disabled={isLoading}
            />
            <div className="flex flex-col sm:flex-row gap-2">
              <Button 
                type="button" 
                variant="outline" 
                onClick={() => setText(SAMPLE_AI_PARAGRAPH)} 
                className="w-full sm:w-auto"
                disabled={isLoading}
              >
                Load Sample ChatGPT Text
              </Button>
              <Button 
                type="submit" 
                className="w-full bg-green-600 hover:bg-green-700"
                disabled={isLoading || !text.trim()}
              >
                {isLoading ? (
                  <><Loader2 className="w-5 h-5 mr-2 animate-spin" /> {LOADING_MESSAGES[loadingMessageIndex]}</>
                ) : (
                  <><ArrowRightIcon className="w-5 h-5 mr-2" /> Check text</>
                )}
              </Button>
            </div>
          </form>
        </CardContent>

        {error && (
          <CardFooter className="flex-col items-start gap-y-2">
            <Alert variant="destructive">
              <AlertCircle className="w-4 h-4" />
              <AlertTitle>Error</AlertTitle>
              <AlertDescription>{error}</AlertDescription>
            </Alert>
          </CardFooter>
        )}

        {result && (
          <CardFooter className="flex-col items-start gap-y-4 pt-6">
            <div className="w-full p-4 border rounded-md bg-muted/30">
              <h3 className="mb-2 text-lg font-semibold">Detection Result:</h3>
              <p className="text-2xl font-bold">
                Overall Score: <span className={getScoreColor(result.score)}>{(result.score * 100).toFixed(1)}%</span>
                <span className={`ml-2 text-sm font-medium ${getScoreColor(result.score)}`}>({getOverallInterpretation(result.score)})</span>
              </p>
            </div>

            {result.sentence_scores && result.sentence_scores.length > 0 && (
              <div className="w-full p-4 border rounded-md bg-muted/30">
                <h4 className="mb-3 text-md font-semibold">Sentence-Level Analysis:</h4>
                <ul className="space-y-2">
                  {result.sentence_scores.map((item, index) => (
                    <li key={index} className="p-2 text-sm border-b last:border-b-0">
                      <span className={`font-medium ${getScoreColor(item.score)}`}>
                        [{(item.score * 100).toFixed(1)}% AI]: 
                      </span> 
                      {item.sentence}
                    </li>
                  ))}
                </ul>
              </div>
            )}
          </CardFooter>
        )}
      </Card>
      <LoginPromptModal isOpen={showLoginPrompt} onOpenChange={setShowLoginPrompt} />
    </>
  );
} 